"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackCollection = exports.CloudAssembly = exports.ExtendedStackSelection = exports.DefaultSelection = void 0;
const cxapi = require("@aws-cdk/cx-api");
const colors = require("colors/safe");
const minimatch = require("minimatch");
const semver = require("semver");
const logging_1 = require("../../logging");
const version_1 = require("../../version");
var DefaultSelection;
(function (DefaultSelection) {
    /**
     * Returns an empty selection in case there are no selectors.
     */
    DefaultSelection["None"] = "none";
    /**
     * If the app includes a single stack, returns it. Otherwise throws an exception.
     * This behavior is used by "deploy".
     */
    DefaultSelection["OnlySingle"] = "single";
    /**
     * Returns all stacks in the main (top level) assembly only.
     */
    DefaultSelection["MainAssembly"] = "main";
    /**
     * If no selectors are provided, returns all stacks in the app,
     * including stacks inside nested assemblies.
     */
    DefaultSelection["AllStacks"] = "all";
})(DefaultSelection = exports.DefaultSelection || (exports.DefaultSelection = {}));
/**
 * When selecting stacks, what other stacks to include because of dependencies
 */
var ExtendedStackSelection;
(function (ExtendedStackSelection) {
    /**
     * Don't select any extra stacks
     */
    ExtendedStackSelection[ExtendedStackSelection["None"] = 0] = "None";
    /**
     * Include stacks that this stack depends on
     */
    ExtendedStackSelection[ExtendedStackSelection["Upstream"] = 1] = "Upstream";
    /**
     * Include stacks that depend on this stack
     */
    ExtendedStackSelection[ExtendedStackSelection["Downstream"] = 2] = "Downstream";
})(ExtendedStackSelection = exports.ExtendedStackSelection || (exports.ExtendedStackSelection = {}));
/**
 * A single Cloud Assembly and the operations we do on it to deploy the artifacts inside
 */
class CloudAssembly {
    constructor(assembly) {
        this.assembly = assembly;
        this.directory = assembly.directory;
    }
    async selectStacks(selectors, options) {
        selectors = selectors.filter(s => s != null); // filter null/undefined
        selectors = [...new Set(selectors)]; // make them unique
        const stacks = this.assembly.stacksRecursively;
        if (stacks.length === 0) {
            throw new Error('This app contains no stacks');
        }
        if (selectors.length === 0) {
            const topLevelStacks = this.assembly.stacks;
            switch (options.defaultBehavior) {
                case DefaultSelection.MainAssembly:
                    return new StackCollection(this, topLevelStacks);
                case DefaultSelection.AllStacks:
                    return new StackCollection(this, stacks);
                case DefaultSelection.None:
                    return new StackCollection(this, []);
                case DefaultSelection.OnlySingle:
                    if (topLevelStacks.length === 1) {
                        return new StackCollection(this, topLevelStacks);
                    }
                    else {
                        throw new Error('Since this app includes more than a single stack, specify which stacks to use (wildcards are supported) or specify `--all`\n' +
                            `Stacks: ${stacks.map(x => x.id).join(' ')}`);
                    }
                default:
                    throw new Error(`invalid default behavior: ${options.defaultBehavior}`);
            }
        }
        const allStacks = new Map();
        for (const stack of stacks) {
            allStacks.set(stack.hierarchicalId, stack);
        }
        // For every selector argument, pick stacks from the list.
        const selectedStacks = new Map();
        for (const pattern of selectors) {
            let found = false;
            for (const stack of stacks) {
                const hierarchicalId = stack.hierarchicalId;
                if (minimatch(hierarchicalId, pattern) && !selectedStacks.has(hierarchicalId)) {
                    selectedStacks.set(hierarchicalId, stack);
                    found = true;
                }
                else if (minimatch(stack.id, pattern) && !selectedStacks.has(hierarchicalId) && semver.major(version_1.versionNumber()) < 2) {
                    logging_1.warning('Selecting stack by identifier "%s". This identifier is deprecated and will be removed in v2. Please use "%s" instead.', colors.bold(stack.id), colors.bold(stack.hierarchicalId));
                    logging_1.warning('Run "cdk ls" to see a list of all stack identifiers');
                    selectedStacks.set(hierarchicalId, stack);
                    found = true;
                }
            }
            if (!found) {
                throw new Error(`No stack found matching '${pattern}'. Use "list" to print manifest`);
            }
        }
        const extend = options.extend || ExtendedStackSelection.None;
        switch (extend) {
            case ExtendedStackSelection.Downstream:
                includeDownstreamStacks(selectedStacks, allStacks);
                break;
            case ExtendedStackSelection.Upstream:
                includeUpstreamStacks(selectedStacks, allStacks);
                break;
        }
        // Filter original array because it is in the right order
        const selectedList = stacks.filter(s => selectedStacks.has(s.hierarchicalId));
        return new StackCollection(this, selectedList);
    }
    /**
     * Select a single stack by its ID
     */
    stackById(stackId) {
        return new StackCollection(this, [this.assembly.getStackArtifact(stackId)]);
    }
}
exports.CloudAssembly = CloudAssembly;
/**
 * A collection of stacks and related artifacts
 *
 * In practice, not all artifacts in the CloudAssembly are created equal;
 * stacks can be selected independently, but other artifacts such as asset
 * bundles cannot.
 */
class StackCollection {
    constructor(assembly, stackArtifacts) {
        this.assembly = assembly;
        this.stackArtifacts = stackArtifacts;
    }
    get stackCount() {
        return this.stackArtifacts.length;
    }
    get firstStack() {
        if (this.stackCount < 1) {
            throw new Error('StackCollection contains no stack artifacts (trying to access the first one)');
        }
        return this.stackArtifacts[0];
    }
    get stackIds() {
        return this.stackArtifacts.map(s => s.id);
    }
    reversed() {
        const arts = [...this.stackArtifacts];
        arts.reverse();
        return new StackCollection(this.assembly, arts);
    }
    /**
     * Extracts 'aws:cdk:warning|info|error' metadata entries from the stack synthesis
     */
    processMetadataMessages(options = {}) {
        let warnings = false;
        let errors = false;
        for (const stack of this.stackArtifacts) {
            for (const message of stack.messages) {
                switch (message.level) {
                    case cxapi.SynthesisMessageLevel.WARNING:
                        warnings = true;
                        printMessage(logging_1.warning, 'Warning', message.id, message.entry);
                        break;
                    case cxapi.SynthesisMessageLevel.ERROR:
                        errors = true;
                        printMessage(logging_1.error, 'Error', message.id, message.entry);
                        break;
                    case cxapi.SynthesisMessageLevel.INFO:
                        printMessage(logging_1.print, 'Info', message.id, message.entry);
                        break;
                }
            }
        }
        if (errors && !options.ignoreErrors) {
            throw new Error('Found errors');
        }
        if (options.strict && warnings) {
            throw new Error('Found warnings (--strict mode)');
        }
        function printMessage(logFn, prefix, id, entry) {
            logFn(`[${prefix} at ${id}] ${entry.data}`);
            if (options.verbose && entry.trace) {
                logFn(`  ${entry.trace.join('\n  ')}`);
            }
        }
    }
}
exports.StackCollection = StackCollection;
/**
 * Calculate the transitive closure of stack dependents.
 *
 * Modifies `selectedStacks` in-place.
 */
function includeDownstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress;
    do {
        madeProgress = false;
        for (const [id, stack] of allStacks) {
            // Select this stack if it's not selected yet AND it depends on a stack that's in the selected set
            if (!selectedStacks.has(id) && (stack.dependencies || []).some(dep => selectedStacks.has(dep.id))) {
                selectedStacks.set(id, stack);
                added.push(id);
                madeProgress = true;
            }
        }
    } while (madeProgress);
    if (added.length > 0) {
        logging_1.print('Including depending stacks: %s', colors.bold(added.join(', ')));
    }
}
/**
 * Calculate the transitive closure of stack dependencies.
 *
 * Modifies `selectedStacks` in-place.
 */
function includeUpstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress = true;
    while (madeProgress) {
        madeProgress = false;
        for (const stack of selectedStacks.values()) {
            // Select an additional stack if it's not selected yet and a dependency of a selected stack (and exists, obviously)
            for (const dependencyId of stack.dependencies.map(x => { var _a; return (_a = x.manifest.displayName) !== null && _a !== void 0 ? _a : x.id; })) {
                if (!selectedStacks.has(dependencyId) && allStacks.has(dependencyId)) {
                    added.push(dependencyId);
                    selectedStacks.set(dependencyId, allStacks.get(dependencyId));
                    madeProgress = true;
                }
            }
        }
    }
    if (added.length > 0) {
        logging_1.print('Including dependency stacks: %s', colors.bold(added.join(', ')));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWQtYXNzZW1ibHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbG91ZC1hc3NlbWJseS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx5Q0FBeUM7QUFDekMsc0NBQXNDO0FBQ3RDLHVDQUF1QztBQUN2QyxpQ0FBaUM7QUFDakMsMkNBQXNEO0FBQ3RELDJDQUE4QztBQUU5QyxJQUFZLGdCQXNCWDtBQXRCRCxXQUFZLGdCQUFnQjtJQUMxQjs7T0FFRztJQUNILGlDQUFhLENBQUE7SUFFYjs7O09BR0c7SUFDSCx5Q0FBcUIsQ0FBQTtJQUVyQjs7T0FFRztJQUNILHlDQUFxQixDQUFBO0lBRXJCOzs7T0FHRztJQUNILHFDQUFpQixDQUFBO0FBQ25CLENBQUMsRUF0QlcsZ0JBQWdCLEdBQWhCLHdCQUFnQixLQUFoQix3QkFBZ0IsUUFzQjNCO0FBZUQ7O0dBRUc7QUFDSCxJQUFZLHNCQWVYO0FBZkQsV0FBWSxzQkFBc0I7SUFDaEM7O09BRUc7SUFDSCxtRUFBSSxDQUFBO0lBRUo7O09BRUc7SUFDSCwyRUFBUSxDQUFBO0lBRVI7O09BRUc7SUFDSCwrRUFBVSxDQUFBO0FBQ1osQ0FBQyxFQWZXLHNCQUFzQixHQUF0Qiw4QkFBc0IsS0FBdEIsOEJBQXNCLFFBZWpDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLGFBQWE7SUFNeEIsWUFBNEIsUUFBNkI7UUFBN0IsYUFBUSxHQUFSLFFBQVEsQ0FBcUI7UUFDdkQsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0lBQ3RDLENBQUM7SUFFTSxLQUFLLENBQUMsWUFBWSxDQUFDLFNBQW1CLEVBQUUsT0FBNEI7UUFDekUsU0FBUyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyx3QkFBd0I7UUFDdEUsU0FBUyxHQUFHLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxD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QUMsWUFBWSxDQUFDLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsRUFBRTtvQkFDcEUsS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztvQkFDekIsY0FBYyxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsU0FBUyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUUsQ0FBQyxDQUFDO29CQUMvRCxZQUFZLEdBQUcsSUFBSSxDQUFDO2lCQUNyQjthQUNGO1NBQ0Y7S0FDRjtJQUVELElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDcEIsZUFBSyxDQUFDLGlDQUFpQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDekU7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNvbG9ycyBmcm9tICdjb2xvcnMvc2FmZSc7XG5pbXBvcnQgKiBhcyBtaW5pbWF0Y2ggZnJvbSAnbWluaW1hdGNoJztcbmltcG9ydCAqIGFzIHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHsgZXJyb3IsIHByaW50LCB3YXJuaW5nIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyB2ZXJzaW9uTnVtYmVyIH0gZnJvbSAnLi4vLi4vdmVyc2lvbic7XG5cbmV4cG9ydCBlbnVtIERlZmF1bHRTZWxlY3Rpb24ge1xuICAvKipcbiAgICogUmV0dXJucyBhbiBlbXB0eSBzZWxlY3Rpb24gaW4gY2FzZSB0aGVyZSBhcmUgbm8gc2VsZWN0b3JzLlxuICAgKi9cbiAgTm9uZSA9ICdub25lJyxcblxuICAvKipcbiAgICogSWYgdGhlIGFwcCBpbmNsdWRlcyBhIHNpbmdsZSBzdGFjaywgcmV0dXJucyBpdC4gT3RoZXJ3aXNlIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAqIFRoaXMgYmVoYXZpb3IgaXMgdXNlZCBieSBcImRlcGxveVwiLlxuICAgKi9cbiAgT25seVNpbmdsZSA9ICdzaW5nbGUnLFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBzdGFja3MgaW4gdGhlIG1haW4gKHRvcCBsZXZlbCkgYXNzZW1ibHkgb25seS5cbiAgICovXG4gIE1haW5Bc3NlbWJseSA9ICdtYWluJyxcblxuICAvKipcbiAgICogSWYgbm8gc2VsZWN0b3JzIGFyZSBwcm92aWRlZCwgcmV0dXJucyBhbGwgc3RhY2tzIGluIHRoZSBhcHAsXG4gICAqIGluY2x1ZGluZyBzdGFja3MgaW5zaWRlIG5lc3RlZCBhc3NlbWJsaWVzLlxuICAgKi9cbiAgQWxsU3RhY2tzID0gJ2FsbCcsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0U3RhY2tzT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBFeHRlbmQgdGhlIHNlbGVjdGlvbiB0byB1cHN0cmVhZC9kb3duc3RyZWFtIHN0YWNrc1xuICAgKiBAZGVmYXVsdCBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLk5vbmUgb25seSBzZWxlY3QgdGhlIHNwZWNpZmllZCBzdGFja3MuXG4gICAqL1xuICBleHRlbmQ/OiBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgYmVoYXZpb3IgaWYgaWYgbm8gc2VsZWN0b3JzIGFyZSBwcml2aWRlZC5cbiAgICovXG4gIGRlZmF1bHRCZWhhdmlvcjogRGVmYXVsdFNlbGVjdGlvbjtcbn1cblxuLyoqXG4gKiBXaGVuIHNlbGVjdGluZyBzdGFja3MsIHdoYXQgb3RoZXIgc3RhY2tzIHRvIGluY2x1ZGUgYmVjYXVzZSBvZiBkZXBlbmRlbmNpZXNcbiAqL1xuZXhwb3J0IGVudW0gRXh0ZW5kZWRTdGFja1NlbGVjdGlvbiB7XG4gIC8qKlxuICAgKiBEb24ndCBzZWxlY3QgYW55IGV4dHJhIHN0YWNrc1xuICAgKi9cbiAgTm9uZSxcblxuICAvKipcbiAgICogSW5jbHVkZSBzdGFja3MgdGhhdCB0aGlzIHN0YWNrIGRlcGVuZHMgb25cbiAgICovXG4gIFVwc3RyZWFtLFxuXG4gIC8qKlxuICAgKiBJbmNsdWRlIHN0YWNrcyB0aGF0IGRlcGVuZCBvbiB0aGlzIHN0YWNrXG4gICAqL1xuICBEb3duc3RyZWFtXG59XG5cbi8qKlxuICogQSBzaW5nbGUgQ2xvdWQgQXNzZW1ibHkgYW5kIHRoZSBvcGVyYXRpb25zIHdlIGRvIG9uIGl0IHRvIGRlcGxveSB0aGUgYXJ0aWZhY3RzIGluc2lkZVxuICovXG5leHBvcnQgY2xhc3MgQ2xvdWRBc3NlbWJseSB7XG4gIC8qKlxuICAgKiBUaGUgZGlyZWN0b3J5IHRoaXMgQ2xvdWRBc3NlbWJseSB3YXMgcmVhZCBmcm9tXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgZGlyZWN0b3J5OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGFzc2VtYmx5OiBjeGFwaS5DbG91ZEFzc2VtYmx5KSB7XG4gICAgdGhpcy5kaXJlY3RvcnkgPSBhc3NlbWJseS5kaXJlY3Rvcnk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2VsZWN0U3RhY2tzKHNlbGVjdG9yczogc3RyaW5nW10sIG9wdGlvbnM6IFNlbGVjdFN0YWNrc09wdGlvbnMpOiBQcm9taXNlPFN0YWNrQ29sbGVjdGlvbj4ge1xuICAgIHNlbGVjdG9ycyA9IHNlbGVjdG9ycy5maWx0ZXIocyA9PiBzICE9IG51bGwpOyAvLyBmaWx0ZXIgbnVsbC91bmRlZmluZWRcbiAgICBzZWxlY3RvcnMgPSBbLi4ubmV3IFNldChzZWxlY3RvcnMpXTsgLy8gbWFrZSB0aGVtIHVuaXF1ZVxuXG4gICAgY29uc3Qgc3RhY2tzID0gdGhpcy5hc3NlbWJseS5zdGFja3NSZWN1cnNpdmVseTtcbiAgICBpZiAoc3RhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGFwcCBjb250YWlucyBubyBzdGFja3MnKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgdG9wTGV2ZWxTdGFja3MgPSB0aGlzLmFzc2VtYmx5LnN0YWNrcztcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5kZWZhdWx0QmVoYXZpb3IpIHtcbiAgICAgICAgY2FzZSBEZWZhdWx0U2VsZWN0aW9uLk1haW5Bc3NlbWJseTpcbiAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrQ29sbGVjdGlvbih0aGlzLCB0b3BMZXZlbFN0YWNrcyk7XG4gICAgICAgIGNhc2UgRGVmYXVsdFNlbGVjdGlvbi5BbGxTdGFja3M6XG4gICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0NvbGxlY3Rpb24odGhpcywgc3RhY2tzKTtcbiAgICAgICAgY2FzZSBEZWZhdWx0U2VsZWN0aW9uLk5vbmU6XG4gICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0NvbGxlY3Rpb24odGhpcywgW10pO1xuICAgICAgICBjYXNlIERlZmF1bHRTZWxlY3Rpb24uT25seVNpbmdsZTpcbiAgICAgICAgICBpZiAodG9wTGV2ZWxTdGFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrQ29sbGVjdGlvbih0aGlzLCB0b3BMZXZlbFN0YWNrcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2luY2UgdGhpcyBhcHAgaW5jbHVkZXMgbW9yZSB0aGFuIGEgc2luZ2xlIHN0YWNrLCBzcGVjaWZ5IHdoaWNoIHN0YWNrcyB0byB1c2UgKHdpbGRjYXJkcyBhcmUgc3VwcG9ydGVkKSBvciBzcGVjaWZ5IGAtLWFsbGBcXG4nICtcbiAgICAgICAgICAgICAgYFN0YWNrczogJHtzdGFja3MubWFwKHggPT4geC5pZCkuam9pbignICcpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGVmYXVsdCBiZWhhdmlvcjogJHtvcHRpb25zLmRlZmF1bHRCZWhhdmlvcn1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhbGxTdGFja3MgPSBuZXcgTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0PigpO1xuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBhbGxTdGFja3Muc2V0KHN0YWNrLmhpZXJhcmNoaWNhbElkLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLy8gRm9yIGV2ZXJ5IHNlbGVjdG9yIGFyZ3VtZW50LCBwaWNrIHN0YWNrcyBmcm9tIHRoZSBsaXN0LlxuICAgIGNvbnN0IHNlbGVjdGVkU3RhY2tzID0gbmV3IE1hcDxzdHJpbmcsIGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdD4oKTtcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2Ygc2VsZWN0b3JzKSB7XG4gICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgY29uc3QgaGllcmFyY2hpY2FsSWQgPSBzdGFjay5oaWVyYXJjaGljYWxJZDtcbiAgICAgICAgaWYgKG1pbmltYXRjaChoaWVyYXJjaGljYWxJZCwgcGF0dGVybikgJiYgIXNlbGVjdGVkU3RhY2tzLmhhcyhoaWVyYXJjaGljYWxJZCkpIHtcbiAgICAgICAgICBzZWxlY3RlZFN0YWNrcy5zZXQoaGllcmFyY2hpY2FsSWQsIHN0YWNrKTtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobWluaW1hdGNoKHN0YWNrLmlkLCBwYXR0ZXJuKSAmJiAhc2VsZWN0ZWRTdGFja3MuaGFzKGhpZXJhcmNoaWNhbElkKSAmJiBzZW12ZXIubWFqb3IodmVyc2lvbk51bWJlcigpKSA8IDIpIHtcbiAgICAgICAgICB3YXJuaW5nKCdTZWxlY3Rpbmcgc3RhY2sgYnkgaWRlbnRpZmllciBcIiVzXCIuIFRoaXMgaWRlbnRpZmllciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjIuIFBsZWFzZSB1c2UgXCIlc1wiIGluc3RlYWQuJywgY29sb3JzLmJvbGQoc3RhY2suaWQpLCBjb2xvcnMuYm9sZChzdGFjay5oaWVyYXJjaGljYWxJZCkpO1xuICAgICAgICAgIHdhcm5pbmcoJ1J1biBcImNkayBsc1wiIHRvIHNlZSBhIGxpc3Qgb2YgYWxsIHN0YWNrIGlkZW50aWZpZXJzJyk7XG4gICAgICAgICAgc2VsZWN0ZWRTdGFja3Muc2V0KGhpZXJhcmNoaWNhbElkLCBzdGFjayk7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdGFjayBmb3VuZCBtYXRjaGluZyAnJHtwYXR0ZXJufScuIFVzZSBcImxpc3RcIiB0byBwcmludCBtYW5pZmVzdGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGV4dGVuZCA9IG9wdGlvbnMuZXh0ZW5kIHx8IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uTm9uZTtcbiAgICBzd2l0Y2ggKGV4dGVuZCkge1xuICAgICAgY2FzZSBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLkRvd25zdHJlYW06XG4gICAgICAgIGluY2x1ZGVEb3duc3RyZWFtU3RhY2tzKHNlbGVjdGVkU3RhY2tzLCBhbGxTdGFja3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5VcHN0cmVhbTpcbiAgICAgICAgaW5jbHVkZVVwc3RyZWFtU3RhY2tzKHNlbGVjdGVkU3RhY2tzLCBhbGxTdGFja3MpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgb3JpZ2luYWwgYXJyYXkgYmVjYXVzZSBpdCBpcyBpbiB0aGUgcmlnaHQgb3JkZXJcbiAgICBjb25zdCBzZWxlY3RlZExpc3QgPSBzdGFja3MuZmlsdGVyKHMgPT4gc2VsZWN0ZWRTdGFja3MuaGFzKHMuaGllcmFyY2hpY2FsSWQpKTtcblxuICAgIHJldHVybiBuZXcgU3RhY2tDb2xsZWN0aW9uKHRoaXMsIHNlbGVjdGVkTGlzdCk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGEgc2luZ2xlIHN0YWNrIGJ5IGl0cyBJRFxuICAgKi9cbiAgcHVibGljIHN0YWNrQnlJZChzdGFja0lkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFN0YWNrQ29sbGVjdGlvbih0aGlzLCBbdGhpcy5hc3NlbWJseS5nZXRTdGFja0FydGlmYWN0KHN0YWNrSWQpXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2Ygc3RhY2tzIGFuZCByZWxhdGVkIGFydGlmYWN0c1xuICpcbiAqIEluIHByYWN0aWNlLCBub3QgYWxsIGFydGlmYWN0cyBpbiB0aGUgQ2xvdWRBc3NlbWJseSBhcmUgY3JlYXRlZCBlcXVhbDtcbiAqIHN0YWNrcyBjYW4gYmUgc2VsZWN0ZWQgaW5kZXBlbmRlbnRseSwgYnV0IG90aGVyIGFydGlmYWN0cyBzdWNoIGFzIGFzc2V0XG4gKiBidW5kbGVzIGNhbm5vdC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0YWNrQ29sbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBhc3NlbWJseTogQ2xvdWRBc3NlbWJseSwgcHVibGljIHJlYWRvbmx5IHN0YWNrQXJ0aWZhY3RzOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RbXSkge1xuICB9XG5cbiAgcHVibGljIGdldCBzdGFja0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrQXJ0aWZhY3RzLmxlbmd0aDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgZmlyc3RTdGFjaygpIHtcbiAgICBpZiAodGhpcy5zdGFja0NvdW50IDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGFja0NvbGxlY3Rpb24gY29udGFpbnMgbm8gc3RhY2sgYXJ0aWZhY3RzICh0cnlpbmcgdG8gYWNjZXNzIHRoZSBmaXJzdCBvbmUpJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YWNrQXJ0aWZhY3RzWzBdO1xuICB9XG5cbiAgcHVibGljIGdldCBzdGFja0lkcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tBcnRpZmFjdHMubWFwKHMgPT4gcy5pZCk7XG4gIH1cblxuICBwdWJsaWMgcmV2ZXJzZWQoKSB7XG4gICAgY29uc3QgYXJ0cyA9IFsuLi50aGlzLnN0YWNrQXJ0aWZhY3RzXTtcbiAgICBhcnRzLnJldmVyc2UoKTtcbiAgICByZXR1cm4gbmV3IFN0YWNrQ29sbGVjdGlvbih0aGlzLmFzc2VtYmx5LCBhcnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyAnYXdzOmNkazp3YXJuaW5nfGluZm98ZXJyb3InIG1ldGFkYXRhIGVudHJpZXMgZnJvbSB0aGUgc3RhY2sgc3ludGhlc2lzXG4gICAqL1xuICBwdWJsaWMgcHJvY2Vzc01ldGFkYXRhTWVzc2FnZXMob3B0aW9uczogTWV0YWRhdGFNZXNzYWdlT3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHdhcm5pbmdzID0gZmFsc2U7XG4gICAgbGV0IGVycm9ycyA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBzdGFjayBvZiB0aGlzLnN0YWNrQXJ0aWZhY3RzKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2Ygc3RhY2subWVzc2FnZXMpIHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLmxldmVsKSB7XG4gICAgICAgICAgY2FzZSBjeGFwaS5TeW50aGVzaXNNZXNzYWdlTGV2ZWwuV0FSTklORzpcbiAgICAgICAgICAgIHdhcm5pbmdzID0gdHJ1ZTtcbiAgICAgICAgICAgIHByaW50TWVzc2FnZSh3YXJuaW5nLCAnV2FybmluZycsIG1lc3NhZ2UuaWQsIG1lc3NhZ2UuZW50cnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBjeGFwaS5TeW50aGVzaXNNZXNzYWdlTGV2ZWwuRVJST1I6XG4gICAgICAgICAgICBlcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgcHJpbnRNZXNzYWdlKGVycm9yLCAnRXJyb3InLCBtZXNzYWdlLmlkLCBtZXNzYWdlLmVudHJ5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgY3hhcGkuU3ludGhlc2lzTWVzc2FnZUxldmVsLklORk86XG4gICAgICAgICAgICBwcmludE1lc3NhZ2UocHJpbnQsICdJbmZvJywgbWVzc2FnZS5pZCwgbWVzc2FnZS5lbnRyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnJvcnMgJiYgIW9wdGlvbnMuaWdub3JlRXJyb3JzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGVycm9ycycpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0cmljdCAmJiB3YXJuaW5ncykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB3YXJuaW5ncyAoLS1zdHJpY3QgbW9kZSknKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludE1lc3NhZ2UobG9nRm46IChzOiBzdHJpbmcpID0+IHZvaWQsIHByZWZpeDogc3RyaW5nLCBpZDogc3RyaW5nLCBlbnRyeTogY3hhcGkuTWV0YWRhdGFFbnRyeSkge1xuICAgICAgbG9nRm4oYFske3ByZWZpeH0gYXQgJHtpZH1dICR7ZW50cnkuZGF0YX1gKTtcblxuICAgICAgaWYgKG9wdGlvbnMudmVyYm9zZSAmJiBlbnRyeS50cmFjZSkge1xuICAgICAgICBsb2dGbihgICAke2VudHJ5LnRyYWNlLmpvaW4oJ1xcbiAgJyl9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWV0YWRhdGFNZXNzYWdlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGJlIHZlcmJvc2VcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHZlcmJvc2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEb24ndCBzdG9wIG9uIGVycm9yIG1ldGFkYXRhXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpZ25vcmVFcnJvcnM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUcmVhdCB3YXJuaW5ncyBpbiBtZXRhZGF0YSBhcyBlcnJvcnNcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHN0cmljdD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSB0cmFuc2l0aXZlIGNsb3N1cmUgb2Ygc3RhY2sgZGVwZW5kZW50cy5cbiAqXG4gKiBNb2RpZmllcyBgc2VsZWN0ZWRTdGFja3NgIGluLXBsYWNlLlxuICovXG5mdW5jdGlvbiBpbmNsdWRlRG93bnN0cmVhbVN0YWNrcyhcbiAgc2VsZWN0ZWRTdGFja3M6IE1hcDxzdHJpbmcsIGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdD4sXG4gIGFsbFN0YWNrczogTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0Pikge1xuICBjb25zdCBhZGRlZCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgbGV0IG1hZGVQcm9ncmVzcztcbiAgZG8ge1xuICAgIG1hZGVQcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBbaWQsIHN0YWNrXSBvZiBhbGxTdGFja3MpIHtcbiAgICAgIC8vIFNlbGVjdCB0aGlzIHN0YWNrIGlmIGl0J3Mgbm90IHNlbGVjdGVkIHlldCBBTkQgaXQgZGVwZW5kcyBvbiBhIHN0YWNrIHRoYXQncyBpbiB0aGUgc2VsZWN0ZWQgc2V0XG4gICAgICBpZiAoIXNlbGVjdGVkU3RhY2tzLmhhcyhpZCkgJiYgKHN0YWNrLmRlcGVuZGVuY2llcyB8fCBbXSkuc29tZShkZXAgPT4gc2VsZWN0ZWRTdGFja3MuaGFzKGRlcC5pZCkpKSB7XG4gICAgICAgIHNlbGVjdGVkU3RhY2tzLnNldChpZCwgc3RhY2spO1xuICAgICAgICBhZGRlZC5wdXNoKGlkKTtcbiAgICAgICAgbWFkZVByb2dyZXNzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKG1hZGVQcm9ncmVzcyk7XG5cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDApIHtcbiAgICBwcmludCgnSW5jbHVkaW5nIGRlcGVuZGluZyBzdGFja3M6ICVzJywgY29sb3JzLmJvbGQoYWRkZWQuam9pbignLCAnKSkpO1xuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSB0cmFuc2l0aXZlIGNsb3N1cmUgb2Ygc3RhY2sgZGVwZW5kZW5jaWVzLlxuICpcbiAqIE1vZGlmaWVzIGBzZWxlY3RlZFN0YWNrc2AgaW4tcGxhY2UuXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVVcHN0cmVhbVN0YWNrcyhcbiAgc2VsZWN0ZWRTdGFja3M6IE1hcDxzdHJpbmcsIGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdD4sXG4gIGFsbFN0YWNrczogTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0Pikge1xuICBjb25zdCBhZGRlZCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gIGxldCBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICB3aGlsZSAobWFkZVByb2dyZXNzKSB7XG4gICAgbWFkZVByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHNlbGVjdGVkU3RhY2tzLnZhbHVlcygpKSB7XG4gICAgICAvLyBTZWxlY3QgYW4gYWRkaXRpb25hbCBzdGFjayBpZiBpdCdzIG5vdCBzZWxlY3RlZCB5ZXQgYW5kIGEgZGVwZW5kZW5jeSBvZiBhIHNlbGVjdGVkIHN0YWNrIChhbmQgZXhpc3RzLCBvYnZpb3VzbHkpXG4gICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3lJZCBvZiBzdGFjay5kZXBlbmRlbmNpZXMubWFwKHggPT4geC5tYW5pZmVzdC5kaXNwbGF5TmFtZSA/PyB4LmlkKSkge1xuICAgICAgICBpZiAoIXNlbGVjdGVkU3RhY2tzLmhhcyhkZXBlbmRlbmN5SWQpICYmIGFsbFN0YWNrcy5oYXMoZGVwZW5kZW5jeUlkKSkge1xuICAgICAgICAgIGFkZGVkLnB1c2goZGVwZW5kZW5jeUlkKTtcbiAgICAgICAgICBzZWxlY3RlZFN0YWNrcy5zZXQoZGVwZW5kZW5jeUlkLCBhbGxTdGFja3MuZ2V0KGRlcGVuZGVuY3lJZCkhKTtcbiAgICAgICAgICBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDApIHtcbiAgICBwcmludCgnSW5jbHVkaW5nIGRlcGVuZGVuY3kgc3RhY2tzOiAlcycsIGNvbG9ycy5ib2xkKGFkZGVkLmpvaW4oJywgJykpKTtcbiAgfVxufSJdfQ==